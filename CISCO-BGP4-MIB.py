# PySNMP SMI module. Autogenerated from smidump -f python CISCO-BGP4-MIB
# by libsmi2pysnmp-0.1.3 at Thu Aug 28 16:26:54 2014,
# Python version sys.version_info(major=2, minor=7, micro=6, releaselevel='final', serial=0)

# Imports

( Integer, ObjectIdentifier, OctetString, ) = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
( NamedValues, ) = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
( ConstraintsIntersection, ConstraintsUnion, SingleValueConstraint, ValueRangeConstraint, ValueSizeConstraint, ) = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "ConstraintsUnion", "SingleValueConstraint", "ValueRangeConstraint", "ValueSizeConstraint")
( bgpPeerEntry, bgpPeerLastError, bgpPeerRemoteAddr, bgpPeerState, ) = mibBuilder.importSymbols("BGP4-MIB", "bgpPeerEntry", "bgpPeerLastError", "bgpPeerRemoteAddr", "bgpPeerState")
( ciscoMgmt, ) = mibBuilder.importSymbols("CISCO-SMI", "ciscoMgmt")
( InetAddress, InetAddressType, InetAutonomousSystemNumber, InetPortNumber, ) = mibBuilder.importSymbols("INET-ADDRESS-MIB", "InetAddress", "InetAddressType", "InetAutonomousSystemNumber", "InetPortNumber")
( SnmpAdminString, ) = mibBuilder.importSymbols("SNMP-FRAMEWORK-MIB", "SnmpAdminString")
( ModuleCompliance, NotificationGroup, ObjectGroup, ) = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup", "ObjectGroup")
( Bits, Counter32, Gauge32, Integer32, Integer32, IpAddress, ModuleIdentity, MibIdentifier, NotificationType, MibScalar, MibTable, MibTableRow, MibTableColumn, TimeTicks, Unsigned32, ) = mibBuilder.importSymbols("SNMPv2-SMI", "Bits", "Counter32", "Gauge32", "Integer32", "Integer32", "IpAddress", "ModuleIdentity", "MibIdentifier", "NotificationType", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "TimeTicks", "Unsigned32")
( TextualConvention, TruthValue, ) = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "TruthValue")

# Types

class CbgpNetworkAddress(OctetString):
    subtypeSpec = OctetString.subtypeSpec+ValueSizeConstraint(0,255)
    
class CbgpSafi(Integer):
    subtypeSpec = Integer.subtypeSpec+SingleValueConstraint(1,2,3,128,)
    namedValues = NamedValues(("unicast", 1), ("vpn", 128), ("multicast", 2), ("unicastAndMulticast", 3), )
    

# Objects

ciscoBgp4MIB = ModuleIdentity((1, 3, 6, 1, 4, 1, 9, 9, 187)).setRevisions(("2010-09-30 00:00","2003-02-24 00:00","2002-12-19 00:00","2001-08-13 00:00",))
if mibBuilder.loadTexts: ciscoBgp4MIB.setOrganization("Cisco Systems, Inc.")
if mibBuilder.loadTexts: ciscoBgp4MIB.setContactInfo("Cisco Systems\nCustomer Service\n\nPostal: 170 W Tasman Drive\nSan Jose, CA  95134\nUSA\n\nTel: +1 800 553-NETS\n\nE-mail: cs-iprouting-bgp@cisco.com")
if mibBuilder.loadTexts: ciscoBgp4MIB.setDescription("An extension to the IETF BGP4 MIB module defined in\nRFC 1657.\n\nFollowing is the terminology associated with Border\nGateway Protocol(BGP).\n\nUPDATE message\n    UPDATE messages are used to transfer routing \n    information between BGP peers. An UPDATE message \n    is used to advertise a single feasible route to a\n    peer, or to withdraw multiple unfeasible routes \n    from service.                 \n\nAdj-RIBs-In \n   The Adj-RIBs-In store routing information that has\n   been learned from inbound UPDATE messages. Their \n   contents represent routes that are available as an \n   input to the Decision Process.\n\nLoc-RIB(BGP table) \n   The Loc-RIB contains the local routing information\n   that the BGP speaker has selected by applying its \n   local policies to the routing information contained \n   in its Adj-RIBs-In.\n\nAdj-RIBs-Out \n   The Adj-RIBs-Out store the information that the\n   local BGP speaker has selected for advertisement to \n   its peers. The routing information stored in the \n   Adj-RIBs-Out will be carried in the local BGP \n   speaker's UPDATE messages and advertised to its\n   peers.\n\nPath Attributes\n   A variable length sequence of path attributes is \n   present in every UPDATE. Each path attribute is a \n   triple <attribute type, attribute length, \n   attribute value> of variable length. \n\nNetwork Layer Reachability Information(NLRI)\n   A variable length field present in UPDATE messages\n   which contains a list of Network Layer address \n   prefixes. \n\nAddress Family Identifier(AFI) \n   Primary identifier to indicate the type of the \n   Network Layer Reachability Information(NLRI) being \n   carried.\n\nSubsequent Address Family Identifier(SAFI) \n   Secondary identifier to indicate the type of the \n   Network Layer Reachability Information(NLRI) being \n   carried.")
ciscoBgp4NotifyPrefix = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 187, 0))
ciscoBgp4MIBObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 187, 1))
cbgpRoute = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 187, 1, 1))
cbgpRouteTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 187, 1, 1, 1))
if mibBuilder.loadTexts: cbgpRouteTable.setDescription("This table contains information about routes to\ndestination networks from all BGP4 peers.  Since \nBGP4 can carry routes for multiple Network Layer \nprotocols, this table has the Address Family \nIdentifier(AFI) of the Network Layer protocol as the \nfirst index. Further for a given AFI, routes carried\nby BGP4 are distinguished based on Subsequent Address \nFamily Identifiers(SAFI).  Hence that is used as the\nsecond index.  Conceptually there is a separate Loc-RIB\nmaintained by the BGP speaker for each combination of \nAFI and SAFI supported by it.")
cbgpRouteEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 187, 1, 1, 1, 1)).setIndexNames((0, "CISCO-BGP4-MIB", "cbgpRouteAfi"), (0, "CISCO-BGP4-MIB", "cbgpRouteSafi"), (0, "CISCO-BGP4-MIB", "cbgpRoutePeerType"), (0, "CISCO-BGP4-MIB", "cbgpRoutePeer"), (0, "CISCO-BGP4-MIB", "cbgpRouteAddrPrefix"), (0, "CISCO-BGP4-MIB", "cbgpRouteAddrPrefixLen"))
if mibBuilder.loadTexts: cbgpRouteEntry.setDescription("Information about a path to a network received from\na peer.")
cbgpRouteAfi = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 187, 1, 1, 1, 1, 1), InetAddressType()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: cbgpRouteAfi.setDescription("Represents Address Family Identifier(AFI) of the\nNetwork Layer protocol associated with the route.\nAn implementation is only required to support IPv4\nunicast and VPNv4 (Value - 1) address families.")
cbgpRouteSafi = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 187, 1, 1, 1, 1, 2), CbgpSafi()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: cbgpRouteSafi.setDescription("Represents Subsequent Address Family Identifier(SAFI)\nof the route. It gives additional information about\nthe type of the route. An implementation is only \nrequired to support IPv4 unicast(Value - 1) and VPNv4(\nValue - 128) address families.")
cbgpRoutePeerType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 187, 1, 1, 1, 1, 3), InetAddressType()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: cbgpRoutePeerType.setDescription("Represents the type of Network Layer address stored\nin cbgpRoutePeer. An implementation is only required\nto support IPv4 address type(Value - 1).")
cbgpRoutePeer = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 187, 1, 1, 1, 1, 4), InetAddress()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: cbgpRoutePeer.setDescription("The Network Layer address of the peer where the route\ninformation was learned. An implementation is only \nrequired to support an IPv4 peer.")
cbgpRouteAddrPrefix = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 187, 1, 1, 1, 1, 5), CbgpNetworkAddress()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: cbgpRouteAddrPrefix.setDescription("A Network Address prefix in the Network Layer\nReachability Information field of BGP UPDATE message.\nThis object is a Network Address containing the prefix\nwith length specified by cbgpRouteAddrPrefixLen. Any\nbits beyond the length specified by\ncbgpRouteAddrPrefixLen are zeroed.")
cbgpRouteAddrPrefixLen = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 187, 1, 1, 1, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2040))).setMaxAccess("noaccess")
if mibBuilder.loadTexts: cbgpRouteAddrPrefixLen.setDescription("Length in bits of the Network Address prefix in the\nNetwork Layer Reachability Information field.")
cbgpRouteOrigin = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 187, 1, 1, 1, 1, 7), Integer().subtype(subtypeSpec=SingleValueConstraint(2,1,3,)).subtype(namedValues=NamedValues(("igp", 1), ("egp", 2), ("incomplete", 3), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cbgpRouteOrigin.setDescription("The ultimate origin of the route information.")
cbgpRouteASPathSegment = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 187, 1, 1, 1, 1, 8), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cbgpRouteASPathSegment.setDescription("The sequence of AS path segments.  Each AS\npath segment is represented by a triple\n<type, length, value>.\n\nThe type is a 1-octet field which has two\npossible values:\n1  AS_SET: unordered set of ASs a route in the \n          UPDATE message has traversed\n2  AS_SEQUENCE: ordered set of ASs a route in the\n               UPDATE message has traversed.\n\nThe length is a 1-octet field containing the\nnumber of ASs in the value field.\n\nThe value field contains one or more AS\nnumbers, each AS is represented in the octet\nstring as a pair of octets according to the\nfollowing algorithm:\n\nfirst-byte-of-pair = ASNumber / 256;\nsecond-byte-of-pair = ASNumber & 255;")
cbgpRouteNextHop = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 187, 1, 1, 1, 1, 9), CbgpNetworkAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cbgpRouteNextHop.setDescription("The Network Layer address of the border router\nthat should be used for the destination network.")
cbgpRouteMedPresent = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 187, 1, 1, 1, 1, 10), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cbgpRouteMedPresent.setDescription("Indicates the presence/absence of MULTI_EXIT_DISC\nattribute for the route.")
cbgpRouteMultiExitDisc = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 187, 1, 1, 1, 1, 11), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cbgpRouteMultiExitDisc.setDescription("This metric is used to discriminate between multiple\nexit points to an adjacent autonomous system.  The\nvalue of this object is irrelevant if the value of\nof cbgpRouteMedPresent is false(2).")
cbgpRouteLocalPrefPresent = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 187, 1, 1, 1, 1, 12), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cbgpRouteLocalPrefPresent.setDescription("Indicates the presence/absence of LOCAL_PREF\nattribute for the route.")
cbgpRouteLocalPref = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 187, 1, 1, 1, 1, 13), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cbgpRouteLocalPref.setDescription("The degree of preference calculated by the local BGP4\nspeaker for the route. The value of this object is \nirrelevant if the value of cbgpRouteLocalPrefPresent \nis false(2).")
cbgpRouteAtomicAggregate = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 187, 1, 1, 1, 1, 14), Integer().subtype(subtypeSpec=SingleValueConstraint(1,2,)).subtype(namedValues=NamedValues(("lessSpecificRouteNotSelected", 1), ("lessSpecificRouteSelected", 2), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cbgpRouteAtomicAggregate.setDescription("Whether or not the local system has selected a less\nspecific route without selecting a more specific\nroute.")
cbgpRouteAggregatorAS = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 187, 1, 1, 1, 1, 15), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cbgpRouteAggregatorAS.setDescription("The AS number of the last BGP4 speaker that performed\nroute aggregation.  A value of zero (0) indicates the \nabsence of this attribute.")
cbgpRouteAggregatorAddrType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 187, 1, 1, 1, 1, 16), InetAddressType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cbgpRouteAggregatorAddrType.setDescription("Represents the type of Network Layer address stored\nin cbgpRouteAggregatorAddr.")
cbgpRouteAggregatorAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 187, 1, 1, 1, 1, 17), InetAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cbgpRouteAggregatorAddr.setDescription("The Network Layer address of the last BGP4 speaker\nthat performed route aggregation.  A value of all zeros\nindicates the absence of this attribute.")
cbgpRouteBest = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 187, 1, 1, 1, 1, 18), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cbgpRouteBest.setDescription("An indication of whether or not this route was chosen\nas the best BGP4 route.")
cbgpRouteUnknownAttr = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 187, 1, 1, 1, 1, 19), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cbgpRouteUnknownAttr.setDescription("One or more path attributes not understood by this\nBGP4 speaker.  Size zero (0) indicates the absence of\nsuch attribute(s).  Octets beyond the maximum size, if\nany, are not recorded by this object.  \n\nEach path attribute is a triple <attribute type,\nattribute length, attribute value> of variable length.\nAttribute Type is a two-octet field that consists of\nthe Attribute Flags octet followed by the Attribute\nType Code octet.  If the Extended Length bit of the \nAttribute Flags octet is set to 0, the third octet of \nthe Path Attribute contains the length of the\nattribute data in octets.  If the Extended Length bit \nof the Attribute Flags octet is set to 1, then the\nthird and the fourth octets of the path attribute \ncontain the length of the attribute data in octets.\nThe remaining octets of the Path Attribute represent \nthe attribute value and are interpreted according to \nthe Attribute Flags and the Attribute Type Code.")
cbgpPeer = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 187, 1, 2))
cbgpPeerTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 187, 1, 2, 1))
if mibBuilder.loadTexts: cbgpPeerTable.setDescription("BGP peer table.  This table contains,\none entry per BGP peer, information about\nthe connections with BGP peers.")
cbgpPeerEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 187, 1, 2, 1, 1))
if mibBuilder.loadTexts: cbgpPeerEntry.setDescription("Entry containing information about the\nconnection with a BGP peer.")
cbgpPeerPrefixAccepted = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 187, 1, 2, 1, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cbgpPeerPrefixAccepted.setDescription("Number of Route prefixes received on this connnection,\nwhich are accepted after applying filters. Possible\nfilters are route maps, prefix lists, distributed\nlists, etc.")
cbgpPeerPrefixDenied = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 187, 1, 2, 1, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cbgpPeerPrefixDenied.setDescription("Counter which gets incremented when a route prefix\nreceived on this connection is denied  or when a route\nprefix is denied during soft reset of this connection\nif 'soft-reconfiguration' is on . This object is \ninitialized to zero when the peer is  configured or\nthe router is rebooted")
cbgpPeerPrefixLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 187, 1, 2, 1, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cbgpPeerPrefixLimit.setDescription("Max number of route prefixes accepted on this\nconnection")
cbgpPeerPrefixAdvertised = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 187, 1, 2, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cbgpPeerPrefixAdvertised.setDescription("Counter which gets incremented when a route prefix\nis advertised on this connection. This object is\ninitialized to zero when the peer is configured or \nthe router is rebooted")
cbgpPeerPrefixSuppressed = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 187, 1, 2, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cbgpPeerPrefixSuppressed.setDescription("Counter which gets incremented when a route prefix\nis suppressed from being sent on this connection. This \nobject is initialized to zero when the peer is \nconfigured or the router is rebooted")
cbgpPeerPrefixWithdrawn = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 187, 1, 2, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cbgpPeerPrefixWithdrawn.setDescription("Counter which gets incremented when a route prefix\nis withdrawn on this connection. This object is\ninitialized to zero when the peer is configured or\nthe router is rebooted")
cbgpPeerLastErrorTxt = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 187, 1, 2, 1, 1, 7), SnmpAdminString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cbgpPeerLastErrorTxt.setDescription("Implementation specific error description for\nbgpPeerLastErrorReceived.")
cbgpPeerPrevState = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 187, 1, 2, 1, 1, 8), Integer().subtype(subtypeSpec=SingleValueConstraint(6,0,5,2,3,4,1,)).subtype(namedValues=NamedValues(("none", 0), ("idle", 1), ("connect", 2), ("active", 3), ("opensent", 4), ("openconfirm", 5), ("established", 6), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cbgpPeerPrevState.setDescription("The BGP peer connection previous state.")
cbgpPeerCapsTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 187, 1, 2, 2))
if mibBuilder.loadTexts: cbgpPeerCapsTable.setDescription("This table contains the capabilities that are\nsupported by a peer. Capabilities of a peer are \nreceived during BGP connection establishment.\nValues corresponding to each received capability\nare stored in this table. When a new capability \nis received, this table is updated with a new \nentry. When an existing capability is not received \nduring the latest connection establishment, the \ncorresponding entry is deleted from the table.")
cbgpPeerCapsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 187, 1, 2, 2, 1)).setIndexNames((0, "BGP4-MIB", "bgpPeerRemoteAddr"), (0, "CISCO-BGP4-MIB", "cbgpPeerCapCode"), (0, "CISCO-BGP4-MIB", "cbgpPeerCapIndex"))
if mibBuilder.loadTexts: cbgpPeerCapsEntry.setDescription("Each entry represents a capability received from a\npeer with a particular code and an index. When a \ncapability is received multiple times with different\nvalues during a BGP connection establishment, \ncorresponding entries are differentiated with indices.")
cbgpPeerCapCode = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 187, 1, 2, 2, 1, 1), Integer().subtype(subtypeSpec=SingleValueConstraint(2,64,1,128,)).subtype(namedValues=NamedValues(("multiProtocol", 1), ("routeRefreshOld", 128), ("routeRefresh", 2), ("gracefulRestart", 64), ))).setMaxAccess("noaccess")
if mibBuilder.loadTexts: cbgpPeerCapCode.setDescription("The BGP Capability Advertisement Capability Code.")
cbgpPeerCapIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 187, 1, 2, 2, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 128))).setMaxAccess("noaccess")
if mibBuilder.loadTexts: cbgpPeerCapIndex.setDescription("Multiple instances of a given capability may be\nsent by a BGP speaker.  This variable is used\nto index them.")
cbgpPeerCapValue = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 187, 1, 2, 2, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cbgpPeerCapValue.setDescription("The value of the announced capability. This\nMIB object value is organized as given below,\n    Capability : Route Refresh Capability\n                 Null string\n    Capability : Multiprotocol Extensions\n      +----------------------------------+\n      | AFI(16 bits)                     |\n      +----------------------------------+\n      | SAFI (8 bits)                    |\n      +----------------------------------+\n    Capability : Graceful Restart\n      +----------------------------------+\n      | Restart Flags (4 bits)           |\n      +----------------------------------+\n      | Restart Time in seconds (12 bits)|\n      +----------------------------------+\n      | AFI(16 bits)                     |\n      +----------------------------------+\n      | SAFI (8 bits)                    |\n      +----------------------------------+\n      | Flags for Address Family (8 bits)|\n      +----------------------------------+\n      | ...                              |\n      +----------------------------------+\n      | AFI(16 bits)                     |\n      +----------------------------------+\n      | SAFI (8 bits)                    |\n      +----------------------------------+\n      | Flags for Address Family (8 bits)|\n      +----------------------------------+")
cbgpPeerAddrFamilyTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 187, 1, 2, 3))
if mibBuilder.loadTexts: cbgpPeerAddrFamilyTable.setDescription("This table contains information related to\naddress families supported by a peer. Supported\naddress families of a peer are known during BGP \nconnection establishment. When a new supported \naddress family is known, this table is updated \nwith a new entry. When an address family is not \nsupported any more, corresponding entry is deleted \nfrom the table.")
cbgpPeerAddrFamilyEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 187, 1, 2, 3, 1)).setIndexNames((0, "BGP4-MIB", "bgpPeerRemoteAddr"), (0, "CISCO-BGP4-MIB", "cbgpPeerAddrFamilyAfi"), (0, "CISCO-BGP4-MIB", "cbgpPeerAddrFamilySafi"))
if mibBuilder.loadTexts: cbgpPeerAddrFamilyEntry.setDescription("An entry is identified by an AFI/SAFI pair and\npeer address. It contains names associated with\nan address family.")
cbgpPeerAddrFamilyAfi = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 187, 1, 2, 3, 1, 1), InetAddressType()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: cbgpPeerAddrFamilyAfi.setDescription("The AFI index of the entry. An implementation\nis only required to support IPv4 unicast and \nVPNv4 (Value - 1) address families.")
cbgpPeerAddrFamilySafi = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 187, 1, 2, 3, 1, 2), CbgpSafi()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: cbgpPeerAddrFamilySafi.setDescription("The SAFI index of the entry. An implementation\nis only required to support IPv4 unicast(Value \n- 1) and VPNv4( Value - 128) address families.")
cbgpPeerAddrFamilyName = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 187, 1, 2, 3, 1, 3), SnmpAdminString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cbgpPeerAddrFamilyName.setDescription("Implementation specific Address Family name.")
cbgpPeerAddrFamilyPrefixTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 187, 1, 2, 4))
if mibBuilder.loadTexts: cbgpPeerAddrFamilyPrefixTable.setDescription("This table contains prefix related information\nrelated to address families supported by a peer. \nSupported address families of a peer are known \nduring BGP connection establishment. When a new \nsupported address family is known, this table \nis updated with a new entry. When an address \nfamily is not supported any more, corresponding \nentry is deleted from the table.")
cbgpPeerAddrFamilyPrefixEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 187, 1, 2, 4, 1)).setIndexNames((0, "BGP4-MIB", "bgpPeerRemoteAddr"), (0, "CISCO-BGP4-MIB", "cbgpPeerAddrFamilyAfi"), (0, "CISCO-BGP4-MIB", "cbgpPeerAddrFamilySafi"))
if mibBuilder.loadTexts: cbgpPeerAddrFamilyPrefixEntry.setDescription("An entry is identified by an AFI/SAFI pair and\npeer address. It contains information associated \nwith route prefixes belonging to an address family.")
cbgpPeerAcceptedPrefixes = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 187, 1, 2, 4, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cbgpPeerAcceptedPrefixes.setDescription("Number of accepted route prefixes on this connection,\nwhich belong to an address family.")
cbgpPeerDeniedPrefixes = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 187, 1, 2, 4, 1, 2), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cbgpPeerDeniedPrefixes.setDescription("This counter is incremented when a route prefix, which\nbelongs to an address family, received on this \nconnection is denied. It is initialized to zero when \nthe connection is undergone a hard reset.")
cbgpPeerPrefixAdminLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 187, 1, 2, 4, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cbgpPeerPrefixAdminLimit.setDescription("Max number of route prefixes accepted for an address\nfamily on this connection.")
cbgpPeerPrefixThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 187, 1, 2, 4, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cbgpPeerPrefixThreshold.setDescription("Prefix threshold value (%) for an address family\non this connection at which warning message stating\nthe prefix count is crossed the threshold or \ncorresponding SNMP notification is generated.")
cbgpPeerPrefixClearThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 187, 1, 2, 4, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cbgpPeerPrefixClearThreshold.setDescription("Prefix threshold value (%) for an address family\non this connection at which SNMP clear notification\nis generated if prefix threshold notification is\nalready generated.")
cbgpPeerAdvertisedPrefixes = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 187, 1, 2, 4, 1, 6), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cbgpPeerAdvertisedPrefixes.setDescription("This counter is incremented when a route prefix,\nwhich belongs to an address family is advertised\non this connection. It is initialized to zero when \nthe connection is undergone a hard reset.")
cbgpPeerSuppressedPrefixes = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 187, 1, 2, 4, 1, 7), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cbgpPeerSuppressedPrefixes.setDescription("This counter is incremented when a route prefix,\nwhich belongs to an address family is suppressed\nfrom being sent on this connection. It is \ninitialized to zero when the connection is undergone\na hard reset.")
cbgpPeerWithdrawnPrefixes = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 187, 1, 2, 4, 1, 8), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cbgpPeerWithdrawnPrefixes.setDescription("This counter is incremented when a route prefix,\nwhich belongs to an address family, is withdrawn on\nthis connection. It is initialized to zero when the\nconnection is undergone a hard reset.")
cbgpPeer2Table = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 187, 1, 2, 5))
if mibBuilder.loadTexts: cbgpPeer2Table.setDescription("BGP peer table.  This table contains,\none entry per BGP peer, information about\nthe connections with BGP peers.")
cbgpPeer2Entry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 187, 1, 2, 5, 1)).setIndexNames((0, "CISCO-BGP4-MIB", "cbgpPeer2Type"), (0, "CISCO-BGP4-MIB", "cbgpPeer2RemoteAddr"))
if mibBuilder.loadTexts: cbgpPeer2Entry.setDescription("Entry containing information about the\nconnection with a BGP peer.")
cbgpPeer2Type = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 187, 1, 2, 5, 1, 1), InetAddressType()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: cbgpPeer2Type.setDescription("Represents the type of Peer address stored\nin cbgpPeer2Entry.")
cbgpPeer2RemoteAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 187, 1, 2, 5, 1, 2), InetAddress()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: cbgpPeer2RemoteAddr.setDescription("The remote IP address of this entry's BGP\npeer.")
cbgpPeer2State = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 187, 1, 2, 5, 1, 3), Integer().subtype(subtypeSpec=SingleValueConstraint(6,5,4,1,2,3,)).subtype(namedValues=NamedValues(("idle", 1), ("connect", 2), ("active", 3), ("opensent", 4), ("openconfirm", 5), ("established", 6), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cbgpPeer2State.setDescription("The BGP peer connection state.")
cbgpPeer2AdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 187, 1, 2, 5, 1, 4), Integer().subtype(subtypeSpec=SingleValueConstraint(2,1,)).subtype(namedValues=NamedValues(("stop", 1), ("start", 2), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cbgpPeer2AdminStatus.setDescription("The desired state of the BGP connection.\nA transition from 'stop' to 'start' will cause\nthe BGP Manual Start Event to be generated.\nA transition from 'start' to 'stop' will cause\nthe BGP Manual Stop Event to be generated.\nThis parameter can be used to restart BGP peer\nconnections.  Care should be used in providing\nwrite access to this object without adequate\nauthentication.")
cbgpPeer2NegotiatedVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 187, 1, 2, 5, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cbgpPeer2NegotiatedVersion.setDescription("The negotiated version of BGP running between\nthe two peers.\n\nThis entry MUST be zero (0) unless the\ncbgpPeer2State is in the openconfirm or the\nestablished state.\n\nNote that legal values for this object are\nbetween 0 and 255.")
cbgpPeer2LocalAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 187, 1, 2, 5, 1, 6), InetAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cbgpPeer2LocalAddr.setDescription("The local IP address of this entry's BGP\nconnection.")
cbgpPeer2LocalPort = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 187, 1, 2, 5, 1, 7), InetPortNumber()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cbgpPeer2LocalPort.setDescription("The local port for the TCP connection between\nthe BGP peers.")
cbgpPeer2LocalAs = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 187, 1, 2, 5, 1, 8), InetAutonomousSystemNumber()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cbgpPeer2LocalAs.setDescription("The local AS number for this session.")
cbgpPeer2LocalIdentifier = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 187, 1, 2, 5, 1, 9), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cbgpPeer2LocalIdentifier.setDescription("The BGP Identifier of this entry's BGP peer.")
cbgpPeer2RemotePort = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 187, 1, 2, 5, 1, 10), InetPortNumber()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cbgpPeer2RemotePort.setDescription("The remote port for the TCP connection\nbetween the BGP peers.  Note that the\nobjects cbgpPeer2LocalAddr,\ncbgpPeer2LocalPort, cbgpPeer2RemoteAddr, and\ncbgpPeer2RemotePort provide the appropriate\nreference to the standard MIB TCP\nconnection table.")
cbgpPeer2RemoteAs = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 187, 1, 2, 5, 1, 11), InetAutonomousSystemNumber()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cbgpPeer2RemoteAs.setDescription("The remote autonomous system number received in\nthe BGP OPEN message.")
cbgpPeer2RemoteIdentifier = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 187, 1, 2, 5, 1, 12), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cbgpPeer2RemoteIdentifier.setDescription("The BGP Identifier of this entry's BGP peer.\nThis entry MUST be 0.0.0.0 unless the\ncbgpPeer2State is in the openconfirm or the\nestablished state.")
cbgpPeer2InUpdates = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 187, 1, 2, 5, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cbgpPeer2InUpdates.setDescription("The number of BGP UPDATE messages\nreceived on this connection.")
cbgpPeer2OutUpdates = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 187, 1, 2, 5, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cbgpPeer2OutUpdates.setDescription("The number of BGP UPDATE messages\ntransmitted on this connection.")
cbgpPeer2InTotalMessages = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 187, 1, 2, 5, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cbgpPeer2InTotalMessages.setDescription("The total number of messages received\nfrom the remote peer on this connection.")
cbgpPeer2OutTotalMessages = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 187, 1, 2, 5, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cbgpPeer2OutTotalMessages.setDescription("The total number of messages transmitted to\nthe remote peer on this connection.")
cbgpPeer2LastError = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 187, 1, 2, 5, 1, 17), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: cbgpPeer2LastError.setDescription("The last error code and subcode seen by this\npeer on this connection.  If no error has\noccurred, this field is zero.  Otherwise, the\nfirst byte of this two byte OCTET STRING\ncontains the error code, and the second byte\ncontains the subcode.")
cbgpPeer2FsmEstablishedTransitions = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 187, 1, 2, 5, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cbgpPeer2FsmEstablishedTransitions.setDescription("The total number of times the BGP FSM\ntransitioned into the established state\nfor this peer.")
cbgpPeer2FsmEstablishedTime = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 187, 1, 2, 5, 1, 19), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cbgpPeer2FsmEstablishedTime.setDescription("This timer indicates how long (in\nseconds) this peer has been in the\nestablished state or how long\nsince this peer was last in the\nestablished state.  It is set to zero when\na new peer is configured or when the router is\nbooted.")
cbgpPeer2ConnectRetryInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 187, 1, 2, 5, 1, 20), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cbgpPeer2ConnectRetryInterval.setDescription("Time interval (in seconds) for the\nConnectRetry timer.  The suggested value\nfor this timer is 120 seconds.")
cbgpPeer2HoldTime = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 187, 1, 2, 5, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0,0),ValueRangeConstraint(3,65535),))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cbgpPeer2HoldTime.setDescription("Time interval (in seconds) for the Hold\nTimer established with the peer.  The\nvalue of this object is calculated by this\nBGP speaker, using the smaller of the\nvalues in cbgpPeer2HoldTimeConfigured and the\nHold Time received in the OPEN message.\n\nThis value must be at least three seconds\nif it is not zero (0).\n\nIf the Hold Timer has not been established\nwith the peer this object MUST have a value\nof zero (0).\n\nIf the cbgpPeer2HoldTimeConfigured object has\na value of (0), then this object MUST have a\nvalue of (0).")
cbgpPeer2KeepAlive = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 187, 1, 2, 5, 1, 22), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 21845))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cbgpPeer2KeepAlive.setDescription("Time interval (in seconds) for the KeepAlive\ntimer established with the peer.  The value\nof this object is calculated by this BGP\nspeaker such that, when compared with\ncbgpPeer2HoldTime, it has the same proportion\nthat cbgpPeer2KeepAliveConfigured has,\ncompared with cbgpPeer2HoldTimeConfigured.\n\nIf the KeepAlive timer has not been established\nwith the peer, this object MUST have a value\nof zero (0).\n\nIf the of cbgpPeer2KeepAliveConfigured object\nhas a value of (0), then this object MUST have\na value of (0).")
cbgpPeer2HoldTimeConfigured = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 187, 1, 2, 5, 1, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0,0),ValueRangeConstraint(3,65535),))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cbgpPeer2HoldTimeConfigured.setDescription("Time interval (in seconds) for the Hold Time\nconfigured for this BGP speaker with this\npeer.  This value is placed in an OPEN\nmessage sent to this peer by this BGP\nspeaker, and is compared with the Hold\nTime field in an OPEN message received\nfrom the peer when determining the Hold\nTime (cbgpPeer2HoldTime) with the peer.\nThis value must not be less than three\nseconds if it is not zero (0).  If it is\nzero (0), the Hold Time is NOT to be\nestablished with the peer.  The suggested\nvalue for this timer is 90 seconds.")
cbgpPeer2KeepAliveConfigured = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 187, 1, 2, 5, 1, 24), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 21845))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cbgpPeer2KeepAliveConfigured.setDescription("Time interval (in seconds) for the\nKeepAlive timer configured for this BGP\nspeaker with this peer.  The value of this\nobject will only determine the\nKEEPALIVE messages' frequency relative to\nthe value specified in\ncbgpPeer2HoldTimeConfigured; the actual\ntime interval for the KEEPALIVE messages is\nindicated by cbgpPeer2KeepAlive.  A\nreasonable maximum value for this timer\nwould be one third of that of\ncbgpPeer2HoldTimeConfigured.\nIf the value of this object is zero (0),\nno periodical KEEPALIVE messages are sent\nto the peer after the BGP connection has\nbeen established.  The suggested value for\nthis timer is 30 seconds.")
cbgpPeer2MinASOriginationInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 187, 1, 2, 5, 1, 25), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cbgpPeer2MinASOriginationInterval.setDescription("Time interval (in seconds) for the\nMinASOriginationInterval timer.\nThe suggested value for this timer is 15\nseconds.")
cbgpPeer2MinRouteAdvertisementInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 187, 1, 2, 5, 1, 26), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cbgpPeer2MinRouteAdvertisementInterval.setDescription("Time interval (in seconds) for the\nMinRouteAdvertisementInterval timer.\nThe suggested value for this timer is 30\nseconds for EBGP connections and 5\nseconds for IBGP connections.")
cbgpPeer2InUpdateElapsedTime = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 187, 1, 2, 5, 1, 27), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cbgpPeer2InUpdateElapsedTime.setDescription("Elapsed time (in seconds) since the last BGP\nUPDATE message was received from the peer.\nEach time cbgpPeer2InUpdates is incremented,\nthe value of this object is set to zero (0).")
cbgpPeer2LastErrorTxt = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 187, 1, 2, 5, 1, 28), SnmpAdminString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cbgpPeer2LastErrorTxt.setDescription("Implementation specific error description for\nbgpPeerLastErrorReceived.")
cbgpPeer2PrevState = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 187, 1, 2, 5, 1, 29), Integer().subtype(subtypeSpec=SingleValueConstraint(6,0,5,2,3,4,1,)).subtype(namedValues=NamedValues(("none", 0), ("idle", 1), ("connect", 2), ("active", 3), ("opensent", 4), ("openconfirm", 5), ("established", 6), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cbgpPeer2PrevState.setDescription("The BGP peer connection previous state.")
cbgpPeer2CapsTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 187, 1, 2, 6))
if mibBuilder.loadTexts: cbgpPeer2CapsTable.setDescription("This table contains the capabilities that are\nsupported by a peer. Capabilities of a peer are\nreceived during BGP connection establishment.\nValues corresponding to each received capability\nare stored in this table. When a new capability\nis received, this table is updated with a new\nentry. When an existing capability is not received\nduring the latest connection establishment, the\ncorresponding entry is deleted from the table.")
cbgpPeer2CapsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 187, 1, 2, 6, 1)).setIndexNames((0, "CISCO-BGP4-MIB", "cbgpPeer2Type"), (0, "CISCO-BGP4-MIB", "cbgpPeer2RemoteAddr"), (0, "CISCO-BGP4-MIB", "cbgpPeer2CapCode"), (0, "CISCO-BGP4-MIB", "cbgpPeer2CapIndex"))
if mibBuilder.loadTexts: cbgpPeer2CapsEntry.setDescription("Each entry represents a capability received from a\npeer with a particular code and an index. When a\ncapability is received multiple times with different\nvalues during a BGP connection establishment,\ncorresponding entries are differentiated with indices.")
cbgpPeer2CapCode = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 187, 1, 2, 6, 1, 1), Integer().subtype(subtypeSpec=SingleValueConstraint(64,1,69,128,2,65,)).subtype(namedValues=NamedValues(("multiProtocol", 1), ("routeRefreshOld", 128), ("routeRefresh", 2), ("gracefulRestart", 64), ("fourByteAs", 65), ("addPath", 69), ))).setMaxAccess("noaccess")
if mibBuilder.loadTexts: cbgpPeer2CapCode.setDescription("The BGP Capability Advertisement Capability Code.")
cbgpPeer2CapIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 187, 1, 2, 6, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 128))).setMaxAccess("noaccess")
if mibBuilder.loadTexts: cbgpPeer2CapIndex.setDescription("Multiple instances of a given capability may be\nsent by a BGP speaker.  This variable is used\nto index them.")
cbgpPeer2CapValue = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 187, 1, 2, 6, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cbgpPeer2CapValue.setDescription("The value of the announced capability. This\nMIB object value is organized as given below,\n    Capability : Route Refresh Capability\n                 4-Byte AS Capability\n                 Null string\n    Capability : Multiprotocol Extensions\n      +----------------------------------+\n      | AFI(16 bits)                     |\n      +----------------------------------+\n      | SAFI (8 bits)                    |\n      +----------------------------------+\n    Capability : Graceful Restart\n      +----------------------------------+\n      | Restart Flags (4 bits)           |\n      +----------------------------------+\n      | Restart Time in seconds (12 bits)|\n      +----------------------------------+\n      | AFI(16 bits)                     |\n      +----------------------------------+\n      | SAFI (8 bits)                    |\n      +----------------------------------+\n      | Flags for Address Family (8 bits)|\n      +----------------------------------+\n      | ...                              |\n      +----------------------------------+\n      | AFI(16 bits)                     |\n      +----------------------------------+\n      | SAFI (8 bits)                    |\n      +----------------------------------+\n      | Flags for Address Family (8 bits)|\n      +----------------------------------+\n    Capability : Additional Paths\n      +----------------------------------+\n      | AFI(16 bits)                     |\n      +----------------------------------+\n      | SAFI (8 bits)                    |\n      +----------------------------------+\n      | Send/Receive (8 bits)            |\n      +----------------------------------+")
cbgpPeer2AddrFamilyTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 187, 1, 2, 7))
if mibBuilder.loadTexts: cbgpPeer2AddrFamilyTable.setDescription("This table contains information related to\naddress families supported by a peer. Supported\naddress families of a peer are known during BGP\nconnection establishment. When a new supported\naddress family is known, this table is updated\nwith a new entry. When an address family is not\nsupported any more, corresponding entry is deleted\nfrom the table.")
cbgpPeer2AddrFamilyEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 187, 1, 2, 7, 1)).setIndexNames((0, "CISCO-BGP4-MIB", "cbgpPeer2Type"), (0, "CISCO-BGP4-MIB", "cbgpPeer2RemoteAddr"), (0, "CISCO-BGP4-MIB", "cbgpPeer2AddrFamilyAfi"), (0, "CISCO-BGP4-MIB", "cbgpPeer2AddrFamilySafi"))
if mibBuilder.loadTexts: cbgpPeer2AddrFamilyEntry.setDescription("An entry is identified by an AFI/SAFI pair and\npeer address. It contains names associated with\nan address family.")
cbgpPeer2AddrFamilyAfi = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 187, 1, 2, 7, 1, 1), InetAddressType()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: cbgpPeer2AddrFamilyAfi.setDescription("The AFI index of the entry. An implementation\nis only required to support IPv4 unicast and\nVPNv4 (Value - 1) address families.")
cbgpPeer2AddrFamilySafi = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 187, 1, 2, 7, 1, 2), CbgpSafi()).setMaxAccess("noaccess")
if mibBuilder.loadTexts: cbgpPeer2AddrFamilySafi.setDescription("The SAFI index of the entry. An implementation\nis only required to support IPv4 unicast(Value\n- 1) and VPNv4( Value - 128) address families.")
cbgpPeer2AddrFamilyName = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 187, 1, 2, 7, 1, 3), SnmpAdminString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cbgpPeer2AddrFamilyName.setDescription("Implementation specific Address Family name.")
cbgpPeer2AddrFamilyPrefixTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 187, 1, 2, 8))
if mibBuilder.loadTexts: cbgpPeer2AddrFamilyPrefixTable.setDescription("This table contains prefix related information\nrelated to address families supported by a peer.\nSupported address families of a peer are known\nduring BGP connection establishment. When a new\nsupported address family is known, this table\nis updated with a new entry. When an address\nfamily is not supported any more, corresponding\nentry is deleted from the table.")
cbgpPeer2AddrFamilyPrefixEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 187, 1, 2, 8, 1)).setIndexNames((0, "CISCO-BGP4-MIB", "cbgpPeer2Type"), (0, "CISCO-BGP4-MIB", "cbgpPeer2RemoteAddr"), (0, "CISCO-BGP4-MIB", "cbgpPeer2AddrFamilyAfi"), (0, "CISCO-BGP4-MIB", "cbgpPeer2AddrFamilySafi"))
if mibBuilder.loadTexts: cbgpPeer2AddrFamilyPrefixEntry.setDescription("An entry is identified by an AFI/SAFI pair and\npeer address. It contains information associated\nwith route prefixes belonging to an address family.")
cbgpPeer2AcceptedPrefixes = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 187, 1, 2, 8, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cbgpPeer2AcceptedPrefixes.setDescription("Number of accepted route prefixes on this connection,\nwhich belong to an address family.")
cbgpPeer2DeniedPrefixes = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 187, 1, 2, 8, 1, 2), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cbgpPeer2DeniedPrefixes.setDescription("This counter is incremented when a route prefix, which\nbelongs to an address family, received on this\nconnection is denied. It is initialized to zero when\nthe connection is undergone a hard reset.")
cbgpPeer2PrefixAdminLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 187, 1, 2, 8, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cbgpPeer2PrefixAdminLimit.setDescription("Max number of route prefixes accepted for an address\nfamily on this connection.")
cbgpPeer2PrefixThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 187, 1, 2, 8, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cbgpPeer2PrefixThreshold.setDescription("Prefix threshold value (%) for an address family\non this connection at which warning message stating\nthe prefix count is crossed the threshold or\ncorresponding SNMP notification is generated.")
cbgpPeer2PrefixClearThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 187, 1, 2, 8, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cbgpPeer2PrefixClearThreshold.setDescription("Prefix threshold value (%) for an address family\non this connection at which SNMP clear notification\nis generated if prefix threshold notification is\nalready generated.")
cbgpPeer2AdvertisedPrefixes = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 187, 1, 2, 8, 1, 6), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cbgpPeer2AdvertisedPrefixes.setDescription("This counter is incremented when a route prefix,\nwhich belongs to an address family is advertised\non this connection. It is initialized to zero when\nthe connection is undergone a hard reset.")
cbgpPeer2SuppressedPrefixes = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 187, 1, 2, 8, 1, 7), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cbgpPeer2SuppressedPrefixes.setDescription("This counter is incremented when a route prefix,\nwhich belongs to an address family is suppressed\nfrom being sent on this connection. It is\ninitialized to zero when the connection is undergone\na hard reset.")
cbgpPeer2WithdrawnPrefixes = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 187, 1, 2, 8, 1, 8), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cbgpPeer2WithdrawnPrefixes.setDescription("This counter is incremented when a route prefix,\nwhich belongs to an address family, is withdrawn on\nthis connection. It is initialized to zero when the\nconnection is undergone a hard reset.")
cbgpGlobal = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 187, 1, 3))
cbgpNotifsEnable = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 187, 1, 3, 1), Bits().subtype(namedValues=NamedValues(("notifsEnable", 0), ("notifsPeer2Enable", 1), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cbgpNotifsEnable.setDescription("Indicates whether the specific notifications are\nenabled. \nIf notifsEnable(0) bit is set to 1,\nthen the notifications defined in\nciscoBgp4NotificationsGroup1 are enabled; \nIf notifsPeer2Enable(1) bit is set to 1,\nthen the notifications defined in\nciscoBgp4Peer2NotificationsGroup are enabled.")
cbgpLocalAs = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 187, 1, 3, 2), InetAutonomousSystemNumber()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cbgpLocalAs.setDescription("The local autonomous system (AS) number.")
ciscoBgp4NotificationPrefix = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 187, 2))
ciscoBgp4MIBConformance = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 187, 3))
ciscoBgp4MIBCompliances = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 187, 3, 1))
ciscoBgp4MIBGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 187, 3, 2))

# Augmentions
bgpPeerEntry, = mibBuilder.importSymbols("BGP4-MIB", "bgpPeerEntry")
bgpPeerEntry.registerAugmentions(("CISCO-BGP4-MIB", "cbgpPeerEntry"))
cbgpPeerEntry.setIndexNames(*bgpPeerEntry.getIndexNames())

# Notifications

cbgpFsmStateChange = NotificationType((1, 3, 6, 1, 4, 1, 9, 9, 187, 0, 1)).setObjects(*(("CISCO-BGP4-MIB", "cbgpPeerLastErrorTxt"), ("CISCO-BGP4-MIB", "cbgpPeerPrevState"), ("BGP4-MIB", "bgpPeerState"), ("BGP4-MIB", "bgpPeerLastError"), ) )
if mibBuilder.loadTexts: cbgpFsmStateChange.setDescription("The BGP cbgpFsmStateChange notification is generated\nfor every BGP FSM state change. The bgpPeerRemoteAddr\nvalue is attached to the notification object ID.")
cbgpBackwardTransition = NotificationType((1, 3, 6, 1, 4, 1, 9, 9, 187, 0, 2)).setObjects(*(("CISCO-BGP4-MIB", "cbgpPeerLastErrorTxt"), ("CISCO-BGP4-MIB", "cbgpPeerPrevState"), ("BGP4-MIB", "bgpPeerState"), ("BGP4-MIB", "bgpPeerLastError"), ) )
if mibBuilder.loadTexts: cbgpBackwardTransition.setDescription("The cbgpBackwardTransition Event is generated when the\nBGP FSM moves from a higher numbered state to a lower\nnumbered state. The bgpPeerRemoteAddr value is attached\nto the notification object ID.")
cbgpPrefixThresholdExceeded = NotificationType((1, 3, 6, 1, 4, 1, 9, 9, 187, 0, 3)).setObjects(*(("CISCO-BGP4-MIB", "cbgpPeerPrefixAdminLimit"), ("CISCO-BGP4-MIB", "cbgpPeerPrefixThreshold"), ) )
if mibBuilder.loadTexts: cbgpPrefixThresholdExceeded.setDescription("The cbgpPrefixThresholdExceeded notification is\ngenerated when prefix count exceeds the configured\nwarning threshold on a session for an address\nfamily. The bgpPeerRemoteAddr, cbgpPeerAddrFamilyAfi\nand cbgpPeerAddrFamilySafi values are attached to the\nnotification object ID.")
cbgpPrefixThresholdClear = NotificationType((1, 3, 6, 1, 4, 1, 9, 9, 187, 0, 4)).setObjects(*(("CISCO-BGP4-MIB", "cbgpPeerPrefixAdminLimit"), ("CISCO-BGP4-MIB", "cbgpPeerPrefixClearThreshold"), ) )
if mibBuilder.loadTexts: cbgpPrefixThresholdClear.setDescription("The cbgpPrefixThresholdClear notification is\ngenerated when prefix count drops below the configured\nclear threshold on a session for an address family once\ncbgpPrefixThresholdExceeded is generated. This won't\nbe generated if the peer session goes down after the\ngeneration of cbgpPrefixThresholdExceeded.\nThe bgpPeerRemoteAddr, cbgpPeerAddrFamilyAfi and\ncbgpPeerAddrFamilySafi values are attached to the\nnotification object ID.")
cbgpPeer2EstablishedNotification = NotificationType((1, 3, 6, 1, 4, 1, 9, 9, 187, 0, 5)).setObjects(*(("CISCO-BGP4-MIB", "cbgpPeer2LastError"), ("CISCO-BGP4-MIB", "cbgpPeer2State"), ) )
if mibBuilder.loadTexts: cbgpPeer2EstablishedNotification.setDescription("The cbgpPeer2EstablishedNotification notification\nis generated when the BGP FSM enters the established\nstate.")
cbgpPeer2BackwardTransNotification = NotificationType((1, 3, 6, 1, 4, 1, 9, 9, 187, 0, 6)).setObjects(*(("CISCO-BGP4-MIB", "cbgpPeer2LastError"), ("CISCO-BGP4-MIB", "cbgpPeer2State"), ) )
if mibBuilder.loadTexts: cbgpPeer2BackwardTransNotification.setDescription("The cbgpPeer2BackwardTransNotification notification\nis generated when the BGP FSM moves from a higher\nnumbered state to a lower numbered state.")
cbgpPeer2FsmStateChange = NotificationType((1, 3, 6, 1, 4, 1, 9, 9, 187, 0, 7)).setObjects(*(("CISCO-BGP4-MIB", "cbgpPeer2PrevState"), ("CISCO-BGP4-MIB", "cbgpPeer2LastError"), ("CISCO-BGP4-MIB", "cbgpPeer2State"), ("CISCO-BGP4-MIB", "cbgpPeer2LastErrorTxt"), ) )
if mibBuilder.loadTexts: cbgpPeer2FsmStateChange.setDescription("The cbgpPeer2FsmStateChange notification is generated\nfor every BGP FSM state change.")
cbgpPeer2BackwardTransition = NotificationType((1, 3, 6, 1, 4, 1, 9, 9, 187, 0, 8)).setObjects(*(("CISCO-BGP4-MIB", "cbgpPeer2PrevState"), ("CISCO-BGP4-MIB", "cbgpPeer2LastError"), ("CISCO-BGP4-MIB", "cbgpPeer2State"), ("CISCO-BGP4-MIB", "cbgpPeer2LastErrorTxt"), ) )
if mibBuilder.loadTexts: cbgpPeer2BackwardTransition.setDescription("The cbgpPeer2BackwardTransition notification is\ngenerated when the BGP FSM moves from a higher numbered\nstate to a lower numbered state.")
cbgpPeer2PrefixThresholdExceeded = NotificationType((1, 3, 6, 1, 4, 1, 9, 9, 187, 0, 9)).setObjects(*(("CISCO-BGP4-MIB", "cbgpPeer2PrefixThreshold"), ("CISCO-BGP4-MIB", "cbgpPeer2PrefixAdminLimit"), ) )
if mibBuilder.loadTexts: cbgpPeer2PrefixThresholdExceeded.setDescription("The cbgpPeer2PrefixThresholdExceeded notification is\ngenerated when prefix count exceeds the configured\nwarning threshold on a session for an address\nfamily.")
cbgpPeer2PrefixThresholdClear = NotificationType((1, 3, 6, 1, 4, 1, 9, 9, 187, 0, 10)).setObjects(*(("CISCO-BGP4-MIB", "cbgpPeer2PrefixClearThreshold"), ("CISCO-BGP4-MIB", "cbgpPeer2PrefixAdminLimit"), ) )
if mibBuilder.loadTexts: cbgpPeer2PrefixThresholdClear.setDescription("The cbgpPeer2PrefixThresholdClear notification is\ngenerated when prefix count drops below the configured\nclear threshold on a session for an address family once\ncbgpPeer2PrefixThresholdExceeded is generated.\nThis will not be generated if the peer session goes down\nafter the generation of cbgpPrefixThresholdExceeded.")

# Groups

ciscoBgp4RouteGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 187, 3, 2, 1)).setObjects(*(("CISCO-BGP4-MIB", "cbgpRouteAggregatorAddr"), ("CISCO-BGP4-MIB", "cbgpRouteAtomicAggregate"), ("CISCO-BGP4-MIB", "cbgpRouteASPathSegment"), ("CISCO-BGP4-MIB", "cbgpRouteLocalPref"), ("CISCO-BGP4-MIB", "cbgpRouteUnknownAttr"), ("CISCO-BGP4-MIB", "cbgpRouteBest"), ("CISCO-BGP4-MIB", "cbgpRouteNextHop"), ("CISCO-BGP4-MIB", "cbgpRouteMedPresent"), ("CISCO-BGP4-MIB", "cbgpRouteLocalPrefPresent"), ("CISCO-BGP4-MIB", "cbgpRouteOrigin"), ("CISCO-BGP4-MIB", "cbgpRouteAggregatorAS"), ("CISCO-BGP4-MIB", "cbgpRouteAggregatorAddrType"), ("CISCO-BGP4-MIB", "cbgpRouteMultiExitDisc"), ) )
if mibBuilder.loadTexts: ciscoBgp4RouteGroup.setDescription("A collection of objects providing information\nabout routes received by BGP speaker.")
ciscoBgp4PeerGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 187, 3, 2, 2)).setObjects(*(("CISCO-BGP4-MIB", "cbgpPeerPrefixLimit"), ("CISCO-BGP4-MIB", "cbgpPeerPrefixWithdrawn"), ("CISCO-BGP4-MIB", "cbgpPeerPrefixDenied"), ("CISCO-BGP4-MIB", "cbgpPeerPrefixSuppressed"), ("CISCO-BGP4-MIB", "cbgpPeerPrefixAdvertised"), ("CISCO-BGP4-MIB", "cbgpPeerPrefixAccepted"), ) )
if mibBuilder.loadTexts: ciscoBgp4PeerGroup.setDescription("A collection of objects providing information\nabout routes received by BGP speaker.")
ciscoBgp4NotificationsGroup = NotificationGroup((1, 3, 6, 1, 4, 1, 9, 9, 187, 3, 2, 3)).setObjects(*(("CISCO-BGP4-MIB", "cbgpFsmStateChange"), ) )
if mibBuilder.loadTexts: ciscoBgp4NotificationsGroup.setDescription("The collection of notifications related to BGP.")
ciscoBgp4PeerGroup1 = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 187, 3, 2, 4)).setObjects(*(("CISCO-BGP4-MIB", "cbgpPeerAdvertisedPrefixes"), ("CISCO-BGP4-MIB", "cbgpPeerAcceptedPrefixes"), ("CISCO-BGP4-MIB", "cbgpPeerLastErrorTxt"), ("CISCO-BGP4-MIB", "cbgpPeerCapValue"), ("CISCO-BGP4-MIB", "cbgpPeerPrefixAdminLimit"), ("CISCO-BGP4-MIB", "cbgpPeerAddrFamilyName"), ("CISCO-BGP4-MIB", "cbgpPeerPrevState"), ("CISCO-BGP4-MIB", "cbgpPeerPrefixThreshold"), ("CISCO-BGP4-MIB", "cbgpPeerSuppressedPrefixes"), ("CISCO-BGP4-MIB", "cbgpPeerPrefixClearThreshold"), ("CISCO-BGP4-MIB", "cbgpPeerWithdrawnPrefixes"), ("CISCO-BGP4-MIB", "cbgpPeerDeniedPrefixes"), ) )
if mibBuilder.loadTexts: ciscoBgp4PeerGroup1.setDescription("A collection of objects providing information\nabout a BGP peer.")
ciscoBgp4NotificationsGroup1 = NotificationGroup((1, 3, 6, 1, 4, 1, 9, 9, 187, 3, 2, 5)).setObjects(*(("CISCO-BGP4-MIB", "cbgpFsmStateChange"), ("CISCO-BGP4-MIB", "cbgpBackwardTransition"), ("CISCO-BGP4-MIB", "cbgpPrefixThresholdClear"), ("CISCO-BGP4-MIB", "cbgpPrefixThresholdExceeded"), ) )
if mibBuilder.loadTexts: ciscoBgp4NotificationsGroup1.setDescription("The collection of notifications related to BGP.")
ciscoBgp4Peer2Group = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 187, 3, 2, 6)).setObjects(*(("CISCO-BGP4-MIB", "cbgpPeer2NegotiatedVersion"), ("CISCO-BGP4-MIB", "cbgpPeer2RemoteAs"), ("CISCO-BGP4-MIB", "cbgpPeer2FsmEstablishedTime"), ("CISCO-BGP4-MIB", "cbgpPeer2CapValue"), ("CISCO-BGP4-MIB", "cbgpPeer2HoldTime"), ("CISCO-BGP4-MIB", "cbgpPeer2PrefixAdminLimit"), ("CISCO-BGP4-MIB", "cbgpPeer2LocalIdentifier"), ("CISCO-BGP4-MIB", "cbgpPeer2AcceptedPrefixes"), ("CISCO-BGP4-MIB", "cbgpPeer2MinASOriginationInterval"), ("CISCO-BGP4-MIB", "cbgpPeer2OutUpdates"), ("CISCO-BGP4-MIB", "cbgpPeer2InUpdates"), ("CISCO-BGP4-MIB", "cbgpPeer2RemotePort"), ("CISCO-BGP4-MIB", "cbgpPeer2State"), ("CISCO-BGP4-MIB", "cbgpPeer2FsmEstablishedTransitions"), ("CISCO-BGP4-MIB", "cbgpPeer2MinRouteAdvertisementInterval"), ("CISCO-BGP4-MIB", "cbgpPeer2RemoteIdentifier"), ("CISCO-BGP4-MIB", "cbgpPeer2OutTotalMessages"), ("CISCO-BGP4-MIB", "cbgpPeer2PrevState"), ("CISCO-BGP4-MIB", "cbgpPeer2AdvertisedPrefixes"), ("CISCO-BGP4-MIB", "cbgpPeer2PrefixClearThreshold"), ("CISCO-BGP4-MIB", "cbgpPeer2LocalAs"), ("CISCO-BGP4-MIB", "cbgpPeer2LocalAddr"), ("CISCO-BGP4-MIB", "cbgpPeer2InTotalMessages"), ("CISCO-BGP4-MIB", "cbgpPeer2KeepAlive"), ("CISCO-BGP4-MIB", "cbgpPeer2WithdrawnPrefixes"), ("CISCO-BGP4-MIB", "cbgpPeer2AddrFamilyName"), ("CISCO-BGP4-MIB", "cbgpPeer2LastError"), ("CISCO-BGP4-MIB", "cbgpPeer2ConnectRetryInterval"), ("CISCO-BGP4-MIB", "cbgpPeer2SuppressedPrefixes"), ("CISCO-BGP4-MIB", "cbgpPeer2LocalPort"), ("CISCO-BGP4-MIB", "cbgpPeer2AdminStatus"), ("CISCO-BGP4-MIB", "cbgpPeer2InUpdateElapsedTime"), ("CISCO-BGP4-MIB", "cbgpPeer2KeepAliveConfigured"), ("CISCO-BGP4-MIB", "cbgpPeer2LastErrorTxt"), ("CISCO-BGP4-MIB", "cbgpPeer2PrefixThreshold"), ("CISCO-BGP4-MIB", "cbgpPeer2DeniedPrefixes"), ("CISCO-BGP4-MIB", "cbgpPeer2HoldTimeConfigured"), ) )
if mibBuilder.loadTexts: ciscoBgp4Peer2Group.setDescription("A collection of objects providing information\nabout a BGP peer.")
ciscoBgp4Peer2NotificationsGroup = NotificationGroup((1, 3, 6, 1, 4, 1, 9, 9, 187, 3, 2, 7)).setObjects(*(("CISCO-BGP4-MIB", "cbgpPeer2PrefixThresholdClear"), ("CISCO-BGP4-MIB", "cbgpPeer2EstablishedNotification"), ("CISCO-BGP4-MIB", "cbgpPeer2PrefixThresholdExceeded"), ("CISCO-BGP4-MIB", "cbgpPeer2BackwardTransition"), ("CISCO-BGP4-MIB", "cbgpPeer2BackwardTransNotification"), ("CISCO-BGP4-MIB", "cbgpPeer2FsmStateChange"), ) )
if mibBuilder.loadTexts: ciscoBgp4Peer2NotificationsGroup.setDescription("A collection of notifications related to BGP.")
ciscoBgp4GlobalGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 187, 3, 2, 8)).setObjects(*(("CISCO-BGP4-MIB", "cbgpLocalAs"), ("CISCO-BGP4-MIB", "cbgpNotifsEnable"), ) )
if mibBuilder.loadTexts: ciscoBgp4GlobalGroup.setDescription("A collection of global objects related to BGP.")

# Compliances

ciscoBgp4MIBCompliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 9, 187, 3, 1, 1)).setObjects(*(("CISCO-BGP4-MIB", "ciscoBgp4RouteGroup"), ) )
if mibBuilder.loadTexts: ciscoBgp4MIBCompliance.setDescription("The compliance statement for entities which implement\nthe Cisco BGP4 MIB")
ciscoBgp4MIBComplianceRev1 = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 9, 187, 3, 1, 2)).setObjects(*(("CISCO-BGP4-MIB", "ciscoBgp4PeerGroup"), ("CISCO-BGP4-MIB", "ciscoBgp4NotificationsGroup"), ("CISCO-BGP4-MIB", "ciscoBgp4RouteGroup"), ) )
if mibBuilder.loadTexts: ciscoBgp4MIBComplianceRev1.setDescription("The compliance statement for entities which implement\nthe Cisco BGP4 MIB")
ciscoBgp4MIBComplianceRev2 = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 9, 187, 3, 1, 3)).setObjects(*(("CISCO-BGP4-MIB", "ciscoBgp4NotificationsGroup1"), ("CISCO-BGP4-MIB", "ciscoBgp4PeerGroup1"), ("CISCO-BGP4-MIB", "ciscoBgp4RouteGroup"), ) )
if mibBuilder.loadTexts: ciscoBgp4MIBComplianceRev2.setDescription("The compliance statement for entities which implement\nthe Cisco BGP4 MIB")
ciscoBgp4MIBComplianceRev3 = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 9, 187, 3, 1, 4)).setObjects(*(("CISCO-BGP4-MIB", "ciscoBgp4Peer2NotificationsGroup"), ("CISCO-BGP4-MIB", "ciscoBgp4Peer2Group"), ("CISCO-BGP4-MIB", "ciscoBgp4PeerGroup1"), ("CISCO-BGP4-MIB", "ciscoBgp4NotificationsGroup1"), ("CISCO-BGP4-MIB", "ciscoBgp4GlobalGroup"), ("CISCO-BGP4-MIB", "ciscoBgp4RouteGroup"), ) )
if mibBuilder.loadTexts: ciscoBgp4MIBComplianceRev3.setDescription("The compliance statement for entities which implement\nthe Cisco BGP4 MIB")

# Exports

# Module identity
mibBuilder.exportSymbols("CISCO-BGP4-MIB", PYSNMP_MODULE_ID=ciscoBgp4MIB)

# Types
mibBuilder.exportSymbols("CISCO-BGP4-MIB", CbgpNetworkAddress=CbgpNetworkAddress, CbgpSafi=CbgpSafi)

# Objects
mibBuilder.exportSymbols("CISCO-BGP4-MIB", ciscoBgp4MIB=ciscoBgp4MIB, ciscoBgp4NotifyPrefix=ciscoBgp4NotifyPrefix, ciscoBgp4MIBObjects=ciscoBgp4MIBObjects, cbgpRoute=cbgpRoute, cbgpRouteTable=cbgpRouteTable, cbgpRouteEntry=cbgpRouteEntry, cbgpRouteAfi=cbgpRouteAfi, cbgpRouteSafi=cbgpRouteSafi, cbgpRoutePeerType=cbgpRoutePeerType, cbgpRoutePeer=cbgpRoutePeer, cbgpRouteAddrPrefix=cbgpRouteAddrPrefix, cbgpRouteAddrPrefixLen=cbgpRouteAddrPrefixLen, cbgpRouteOrigin=cbgpRouteOrigin, cbgpRouteASPathSegment=cbgpRouteASPathSegment, cbgpRouteNextHop=cbgpRouteNextHop, cbgpRouteMedPresent=cbgpRouteMedPresent, cbgpRouteMultiExitDisc=cbgpRouteMultiExitDisc, cbgpRouteLocalPrefPresent=cbgpRouteLocalPrefPresent, cbgpRouteLocalPref=cbgpRouteLocalPref, cbgpRouteAtomicAggregate=cbgpRouteAtomicAggregate, cbgpRouteAggregatorAS=cbgpRouteAggregatorAS, cbgpRouteAggregatorAddrType=cbgpRouteAggregatorAddrType, cbgpRouteAggregatorAddr=cbgpRouteAggregatorAddr, cbgpRouteBest=cbgpRouteBest, cbgpRouteUnknownAttr=cbgpRouteUnknownAttr, cbgpPeer=cbgpPeer, cbgpPeerTable=cbgpPeerTable, cbgpPeerEntry=cbgpPeerEntry, cbgpPeerPrefixAccepted=cbgpPeerPrefixAccepted, cbgpPeerPrefixDenied=cbgpPeerPrefixDenied, cbgpPeerPrefixLimit=cbgpPeerPrefixLimit, cbgpPeerPrefixAdvertised=cbgpPeerPrefixAdvertised, cbgpPeerPrefixSuppressed=cbgpPeerPrefixSuppressed, cbgpPeerPrefixWithdrawn=cbgpPeerPrefixWithdrawn, cbgpPeerLastErrorTxt=cbgpPeerLastErrorTxt, cbgpPeerPrevState=cbgpPeerPrevState, cbgpPeerCapsTable=cbgpPeerCapsTable, cbgpPeerCapsEntry=cbgpPeerCapsEntry, cbgpPeerCapCode=cbgpPeerCapCode, cbgpPeerCapIndex=cbgpPeerCapIndex, cbgpPeerCapValue=cbgpPeerCapValue, cbgpPeerAddrFamilyTable=cbgpPeerAddrFamilyTable, cbgpPeerAddrFamilyEntry=cbgpPeerAddrFamilyEntry, cbgpPeerAddrFamilyAfi=cbgpPeerAddrFamilyAfi, cbgpPeerAddrFamilySafi=cbgpPeerAddrFamilySafi, cbgpPeerAddrFamilyName=cbgpPeerAddrFamilyName, cbgpPeerAddrFamilyPrefixTable=cbgpPeerAddrFamilyPrefixTable, cbgpPeerAddrFamilyPrefixEntry=cbgpPeerAddrFamilyPrefixEntry, cbgpPeerAcceptedPrefixes=cbgpPeerAcceptedPrefixes, cbgpPeerDeniedPrefixes=cbgpPeerDeniedPrefixes, cbgpPeerPrefixAdminLimit=cbgpPeerPrefixAdminLimit, cbgpPeerPrefixThreshold=cbgpPeerPrefixThreshold, cbgpPeerPrefixClearThreshold=cbgpPeerPrefixClearThreshold, cbgpPeerAdvertisedPrefixes=cbgpPeerAdvertisedPrefixes, cbgpPeerSuppressedPrefixes=cbgpPeerSuppressedPrefixes, cbgpPeerWithdrawnPrefixes=cbgpPeerWithdrawnPrefixes, cbgpPeer2Table=cbgpPeer2Table, cbgpPeer2Entry=cbgpPeer2Entry, cbgpPeer2Type=cbgpPeer2Type, cbgpPeer2RemoteAddr=cbgpPeer2RemoteAddr, cbgpPeer2State=cbgpPeer2State, cbgpPeer2AdminStatus=cbgpPeer2AdminStatus, cbgpPeer2NegotiatedVersion=cbgpPeer2NegotiatedVersion, cbgpPeer2LocalAddr=cbgpPeer2LocalAddr, cbgpPeer2LocalPort=cbgpPeer2LocalPort, cbgpPeer2LocalAs=cbgpPeer2LocalAs, cbgpPeer2LocalIdentifier=cbgpPeer2LocalIdentifier, cbgpPeer2RemotePort=cbgpPeer2RemotePort, cbgpPeer2RemoteAs=cbgpPeer2RemoteAs, cbgpPeer2RemoteIdentifier=cbgpPeer2RemoteIdentifier, cbgpPeer2InUpdates=cbgpPeer2InUpdates, cbgpPeer2OutUpdates=cbgpPeer2OutUpdates, cbgpPeer2InTotalMessages=cbgpPeer2InTotalMessages, cbgpPeer2OutTotalMessages=cbgpPeer2OutTotalMessages, cbgpPeer2LastError=cbgpPeer2LastError, cbgpPeer2FsmEstablishedTransitions=cbgpPeer2FsmEstablishedTransitions, cbgpPeer2FsmEstablishedTime=cbgpPeer2FsmEstablishedTime, cbgpPeer2ConnectRetryInterval=cbgpPeer2ConnectRetryInterval, cbgpPeer2HoldTime=cbgpPeer2HoldTime, cbgpPeer2KeepAlive=cbgpPeer2KeepAlive, cbgpPeer2HoldTimeConfigured=cbgpPeer2HoldTimeConfigured, cbgpPeer2KeepAliveConfigured=cbgpPeer2KeepAliveConfigured, cbgpPeer2MinASOriginationInterval=cbgpPeer2MinASOriginationInterval, cbgpPeer2MinRouteAdvertisementInterval=cbgpPeer2MinRouteAdvertisementInterval, cbgpPeer2InUpdateElapsedTime=cbgpPeer2InUpdateElapsedTime, cbgpPeer2LastErrorTxt=cbgpPeer2LastErrorTxt, cbgpPeer2PrevState=cbgpPeer2PrevState, cbgpPeer2CapsTable=cbgpPeer2CapsTable, cbgpPeer2CapsEntry=cbgpPeer2CapsEntry, cbgpPeer2CapCode=cbgpPeer2CapCode, cbgpPeer2CapIndex=cbgpPeer2CapIndex, cbgpPeer2CapValue=cbgpPeer2CapValue, cbgpPeer2AddrFamilyTable=cbgpPeer2AddrFamilyTable, cbgpPeer2AddrFamilyEntry=cbgpPeer2AddrFamilyEntry, cbgpPeer2AddrFamilyAfi=cbgpPeer2AddrFamilyAfi, cbgpPeer2AddrFamilySafi=cbgpPeer2AddrFamilySafi, cbgpPeer2AddrFamilyName=cbgpPeer2AddrFamilyName, cbgpPeer2AddrFamilyPrefixTable=cbgpPeer2AddrFamilyPrefixTable, cbgpPeer2AddrFamilyPrefixEntry=cbgpPeer2AddrFamilyPrefixEntry, cbgpPeer2AcceptedPrefixes=cbgpPeer2AcceptedPrefixes, cbgpPeer2DeniedPrefixes=cbgpPeer2DeniedPrefixes, cbgpPeer2PrefixAdminLimit=cbgpPeer2PrefixAdminLimit, cbgpPeer2PrefixThreshold=cbgpPeer2PrefixThreshold, cbgpPeer2PrefixClearThreshold=cbgpPeer2PrefixClearThreshold, cbgpPeer2AdvertisedPrefixes=cbgpPeer2AdvertisedPrefixes, cbgpPeer2SuppressedPrefixes=cbgpPeer2SuppressedPrefixes, cbgpPeer2WithdrawnPrefixes=cbgpPeer2WithdrawnPrefixes, cbgpGlobal=cbgpGlobal, cbgpNotifsEnable=cbgpNotifsEnable, cbgpLocalAs=cbgpLocalAs, ciscoBgp4NotificationPrefix=ciscoBgp4NotificationPrefix, ciscoBgp4MIBConformance=ciscoBgp4MIBConformance, ciscoBgp4MIBCompliances=ciscoBgp4MIBCompliances, ciscoBgp4MIBGroups=ciscoBgp4MIBGroups)

# Notifications
mibBuilder.exportSymbols("CISCO-BGP4-MIB", cbgpFsmStateChange=cbgpFsmStateChange, cbgpBackwardTransition=cbgpBackwardTransition, cbgpPrefixThresholdExceeded=cbgpPrefixThresholdExceeded, cbgpPrefixThresholdClear=cbgpPrefixThresholdClear, cbgpPeer2EstablishedNotification=cbgpPeer2EstablishedNotification, cbgpPeer2BackwardTransNotification=cbgpPeer2BackwardTransNotification, cbgpPeer2FsmStateChange=cbgpPeer2FsmStateChange, cbgpPeer2BackwardTransition=cbgpPeer2BackwardTransition, cbgpPeer2PrefixThresholdExceeded=cbgpPeer2PrefixThresholdExceeded, cbgpPeer2PrefixThresholdClear=cbgpPeer2PrefixThresholdClear)

# Groups
mibBuilder.exportSymbols("CISCO-BGP4-MIB", ciscoBgp4RouteGroup=ciscoBgp4RouteGroup, ciscoBgp4PeerGroup=ciscoBgp4PeerGroup, ciscoBgp4NotificationsGroup=ciscoBgp4NotificationsGroup, ciscoBgp4PeerGroup1=ciscoBgp4PeerGroup1, ciscoBgp4NotificationsGroup1=ciscoBgp4NotificationsGroup1, ciscoBgp4Peer2Group=ciscoBgp4Peer2Group, ciscoBgp4Peer2NotificationsGroup=ciscoBgp4Peer2NotificationsGroup, ciscoBgp4GlobalGroup=ciscoBgp4GlobalGroup)

# Compliances
mibBuilder.exportSymbols("CISCO-BGP4-MIB", ciscoBgp4MIBCompliance=ciscoBgp4MIBCompliance, ciscoBgp4MIBComplianceRev1=ciscoBgp4MIBComplianceRev1, ciscoBgp4MIBComplianceRev2=ciscoBgp4MIBComplianceRev2, ciscoBgp4MIBComplianceRev3=ciscoBgp4MIBComplianceRev3)
